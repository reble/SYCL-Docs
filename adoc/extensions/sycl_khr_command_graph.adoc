= sycl_khr_command_graph

== Dependencies

This extension has no dependencies on other extensions.

== Feature test macro

An implementation supporting this extension must predefine the macro
[code]#SYCL_KHR_COMMAND_GRAPH# to one of the values defined in the table below.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

== Usage example

The example below demonstrates the usage of this extension using the
<<subsec:khr-graph-queue-recording-api, queue recording api>> and <<sec:usm,
Unified Shared Memory>> (USM).

[source,,linenums]
----
include::{code_dir}/graph.cpp[lines=4..-1]
----

This extension adds new classes `command_graph` and `node` which follows the
{crs}[common reference semantics] of other SYCL runtime classes.

=== SYCL Graph Terminology [[terminology]]

==== Explicit Graph Building API

[[subsec:khr-graph-queue-recording-api]]
==== Queue Recording API

==== Sub-Graph


[[sec:khr-graph-node]]
== Node class

The [code]#node# class encapsulates a single command within a graph.
This can include normal SYCL commands such as kernels or memory operations, or
even executing another [code]#command_graph# as a subgraph.

Nodes may also contain no commands in which case they can be used to create
transitive dependencies between other nodes, similar to a barrier.

Dependencies between nodes are defined by their edges which represent a "happens
before" relationship.
Edges can either be specified explicitly or inferred from the existing SYCL
mechanisms for defining dependencies between <<command-group, command-groups>>.

The [code]#node# class provides the common reference semantics as defined in
<<sec:reference-semantics>>.

=== Supported node types

The command types supported by the [code]#node# class are listed in
<<table.node.supported.commands>>.

[[table.node.supported.commands]]
.Commands supported by the [code]#node# class
[width="100%",options="header",separator="@",cols="20%,30%,50%"]
|====
@ Command @ Node type @ Description
a@ None
a@
[source]
----
khr::node_type::empty
----
a@ An empty node contains no commands.
a@ Graph execution
a@
[source]
----
khr::node_type::subgraph
----
a@ A subgraph node embeds an executable [code]#command_graph# for execution as
part of a parent graph.

a@ Kernel
a@
[source]
----
khr::node_type::kernel
----
a@ Represents a SYCL kernel execution, such as [code]#handler::parallel_for#.

a@ Memory Copy
a@
[source]
----
khr::node_type::memcpy
----
a@ Represents a memory copy operation, either [code]#handler::memcpy# or
[code]#handler::copy#.

a@ Memset
a@
[source]
----
khr::node_type::memset
----
a@ Represents a memory set operation, such as [code]#handler::memset#.

a@ Memfill
a@
[source]
----
khr::node_type::memfill
----
a@ Represents a memory fill operation, such as [code]#handler::fill#.

a@ Prefetch
a@
[source]
----
khr::node_type::prefetch
----
a@ Represents a prefetch operation, such as [code]#handler::prefetch#.

a@ Memadvise
a@
[source]
----
khr::node_type::memadvise
----
a@ Represents a memory advise operation, such as [code]#handler::memadvise#.

a@ Host-task
a@
[source]
----
khr::node_type::host_task
----
a@ Represents a SYCL <<host-task, Host Task>> command.

|====


=== Node class interface

[source,,linenums]
----
include::{header_dir}/extensions/khr_graph/node.h[lines=4..-1]
----

[[subsec:khr-graph-node-member-funcs]]
=== Member Functions

.[apidef]#khr::node::get_type#
[source, role=synopsis,id=api:khr-node-get-type]
----
node_type get_type() const noexcept
----

_Returns:_ A value representing the type of command this node represents.

'''

.[apidef]#khr::node::get_predecessors#
[source, role=synopsis,id=api:khr-node-get-predecessors]
----
std::vector<node> get_predecessors() const noexcept
----

_Returns:_ A list of the predecessor nodes which this node directly depends on.

'''

.[apidef]#khr::node::get_successors#
[source, role=synopsis,id=api:khr-node-get-successors]
----
std::vector<node> get_successors() const noexcept
----

_Returns:_ A list of the successor nodes which directly depend on this node.

'''

[[subsec:khr-graph-node-static-member-funcs]]
=== Static member functions

.[apidef]#khr::node::get_node_from_event#
[source, role=synopsis,id=api:khr-node-get-node-from-event]
----
static node get_node_from_event(event nodeEvent)
----

_Effects:_ Finds the node associated with an event [code]#nodeEvent# created
from a submission to a queue in the recording state.

_Returns:_ Graph node that was created when the command that returned
[code]#nodeEvent# was submitted.

_Throws:_ An [code]#exception# with error code [code]#errc::invalid# if
[code]#nodeEvent# is not associated with a graph node.

'''

[[subsec:khr-node-properties]]
=== Node properties

The properies that can be provided when adding a [code]#node# to a graph are
described in <<table.properties.graph.node>>.

[[table.properties.graph.node]]
.Properties supported by the [code]#node# class
[width="100%",options="header",separator="@",cols="45%,55%"]
|====
@ Property @ Description
a@
[source]
----
khr::property::node::depends_on
----
a@ The [code]#depends_on# property can be used to specify dependencies for nodes added via
calls to [code]#command_graph::add#. This creates edges in the graph between the node being
added and the dependent nodes.
a@
[source]
----
khr::property::node::depends_on_all_leaves
----
a@ The [code]#depends_on_all_leaves# property specifies that the node being added should
depend on every node currently in the graph which is a leaf node. A leaf node is a node
in the graph does not have any successors (no other nodes depend on it).

|====

The constructors of the node property classes are listed in the
<<table.constructors.properties.graph.node>> table.

[[table.constructors.properties.graph.node]]
.Constructors of the [code]#node# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template<typename... NodeTN>
khr::property::node::depends_on::depends_on(NodeTN... nodes)
----
a@ Constructs a [code]#depends_on# property instance with a copy of all the
[code]#node# objects in parameter pack [code]#nodes#.

a@
[source]
----
khr::property::node::depends_on_all_leaves()
----
a@ Constructs a [code]#depends_on_all_leaves# property instance.

|====

=== Graph

[source, c++]
----
namespace sycl::khr {
// State of a graph
enum class graph_state {
  modifiable,
  executable
};

// New object representing graph
template<graph_state State = graph_state::modifiable>
class command_graph {};

template<>
class command_graph<graph_state::modifiable> {
public:
  command_graph(const context& syclContext, const device& syclDevice,
                const property_list& propList = {});

  command_graph(const queue& syclQueue,
                const property_list& propList = {});

  command_graph<graph_state::executable>
  finalize(const property_list& propList = {}) const;

  void begin_recording(queue& recordingQueue, const property_list& propList = {});
  void begin_recording(const std::vector<queue>& recordingQueues, const property_list& propList = {});

  void end_recording();
  void end_recording(queue& recordingQueue);
  void end_recording(const std::vector<queue>& recordingQueues);

  node add(const property_list& propList = {});

  template<typename T>
  node add(T cgf, const property_list& propList = {});

  node add(dynamic_command_group& dynamicCG, const property_list& propList = {});

  void make_edge(node& src, node& dest);

  void print_graph(std::string path, bool verbose = false) const;

  std::vector<node> get_nodes() const;
  std::vector<node> get_root_nodes() const;
};

template<>
class command_graph<graph_state::executable> {
public:
    command_graph() = delete;
};

}  // namespace sycl::khr
----

==== Graph State

==== Graph Properties [[graph-properties]]

===== No-Cycle-Check Property

[source,c++]
----
namespace sycl::khr::property::graph {
class no_cycle_check {
  public:
    no_cycle_check() = default;
};
}
----

===== Assume-Buffer-Outlives-Graph Property [[assume-buffer-outlives-graph-property]]

[source,c++]
----
namespace sycl::khr::property::graph {
class assume_buffer_outlives_graph {
  public:
    assume_buffer_outlives_graph() = default;
};
}
----

==== Enable-Profiling Property [[enable-profiling]]

[source,c++]
----
namespace sycl::khr::graph {
class enable_profiling {
  public:
    enable_profiling() = default;
};
}
----

==== Graph Member Functions

===== Constructor of the `command_graph` class

===== Member functions of the `command_graph` class

===== Member functions of the `command_graph` class for queue recording

=== Queue Class Modifications

[source, c++]
----
namespace sycl {
namespace khr {
enum class queue_state {
  executing,
  recording
};

} // namespace khr

// New methods added to the sycl::queue class
using namespace khr;
class queue {
public:

  khr::queue_state
  khr_get_state() const;

  khr::command_graph<graph_state::modifiable>
  khr_get_graph() const;

  /* -- graph convenience shortcuts -- */

  event khr_graph(command_graph<graph_state::executable>& graph);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   event depEvent);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   const std::vector<event>& depEvents);
};
} // namespace sycl
----

==== Queue State

==== Transitive Queue Recording

===== Example

==== Queue Properties
      
==== New Queue Member Functions

===== Additional member functions of the `sycl::queue` class

==== New Handler Member Functions

===== Additional member functions of the `sycl::handler` class

=== Exception Safety

=== Command-Group Function Limitations

=== Host Tasks [[host-tasks]]

=== Queue Behavior In Recording Mode

==== Event Limitations

==== Queue Limitations

==== Buffer Limitations

==== Error Handling
