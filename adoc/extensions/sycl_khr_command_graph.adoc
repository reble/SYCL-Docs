= sycl_khr_command_graph

== Dependencies

This extension has no dependencies on other extensions.

== Feature test macro

An implementation supporting this extension must predefine the macro
[code]#SYCL_KHR_COMMAND_GRAPH# to one of the values defined in the
table below.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

== Usage example

The example below demonstrates the usage of this extension.

[source,,linenums]
----
include::{code_dir}/graph.cpp[lines=4..-1]
----

This extension adds new classes `command_graph` and `node` which follows the
{crs}[common reference semantics] of other SYCL runtime classes.

=== SYCL Graph Terminology [[terminology]]

==== Explicit Graph Building API

==== Queue Recording API

==== Sub-Graph

=== Node

[source, c++]
----
namespace sycl::khr {
enum class node_type {
  empty,
  subgraph,
  kernel,
  memcpy,
  memset,
  memfill,
  prefetch,
  memadvise,
  host_task,
};

class node {
public:
  node() = delete;

  node_type get_type() const;

  std::vector<node> get_predecessors() const;

  std::vector<node> get_successors() const;

  static node get_node_from_event(event nodeEvent);
};

}  // sycl::khr
----

:crs: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:reference-semantics

==== Node Member Functions

==== Depends-On Property

[source,c++]
----
namespace sycl::khr::property::node {
class depends_on {
  public:
    template<typename... NodeTN>
    depends_on(NodeTN... nodes);
};
}
----

==== Depends-On-All-Leaves Property
[source,c++]
----
namespace sycl::khr::property::node {
class depends_on_all_leaves {
  public:
    depends_on_all_leaves() = default;
};
}
----

=== Graph

[source, c++]
----
namespace sycl::khr {
// State of a graph
enum class graph_state {
  modifiable,
  executable
};

// New object representing graph
template<graph_state State = graph_state::modifiable>
class command_graph {};

template<>
class command_graph<graph_state::modifiable> {
public:
  command_graph(const context& syclContext, const device& syclDevice,
                const property_list& propList = {});

  command_graph(const queue& syclQueue,
                const property_list& propList = {});

  command_graph<graph_state::executable>
  finalize(const property_list& propList = {}) const;

  void begin_recording(queue& recordingQueue, const property_list& propList = {});
  void begin_recording(const std::vector<queue>& recordingQueues, const property_list& propList = {});

  void end_recording();
  void end_recording(queue& recordingQueue);
  void end_recording(const std::vector<queue>& recordingQueues);

  node add(const property_list& propList = {});

  template<typename T>
  node add(T cgf, const property_list& propList = {});

  node add(dynamic_command_group& dynamicCG, const property_list& propList = {});

  void make_edge(node& src, node& dest);

  void print_graph(std::string path, bool verbose = false) const;

  std::vector<node> get_nodes() const;
  std::vector<node> get_root_nodes() const;
};

template<>
class command_graph<graph_state::executable> {
public:
    command_graph() = delete;
};

}  // namespace sycl::khr
----

==== Graph State

==== Graph Properties [[graph-properties]]

===== No-Cycle-Check Property

[source,c++]
----
namespace sycl::khr::property::graph {
class no_cycle_check {
  public:
    no_cycle_check() = default;
};
}
----

===== Assume-Buffer-Outlives-Graph Property [[assume-buffer-outlives-graph-property]]

[source,c++]
----
namespace sycl::khr::property::graph {
class assume_buffer_outlives_graph {
  public:
    assume_buffer_outlives_graph() = default;
};
}
----

==== Enable-Profiling Property [[enable-profiling]]

[source,c++]
----
namespace sycl::khr::graph {
class enable_profiling {
  public:
    enable_profiling() = default;
};
}
----

==== Graph Member Functions

===== Constructor of the `command_graph` class

===== Member functions of the `command_graph` class

===== Member functions of the `command_graph` class for queue recording

=== Queue Class Modifications

[source, c++]
----
namespace sycl {
namespace khr {
enum class queue_state {
  executing,
  recording
};

} // namespace khr

// New methods added to the sycl::queue class
using namespace khr;
class queue {
public:

  khr::queue_state
  khr_get_state() const;

  khr::command_graph<graph_state::modifiable>
  khr_get_graph() const;

  /* -- graph convenience shortcuts -- */

  event khr_graph(command_graph<graph_state::executable>& graph);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   event depEvent);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   const std::vector<event>& depEvents);
};
} // namespace sycl
----

==== Queue State

==== Transitive Queue Recording

===== Example

==== Queue Properties
      
==== New Queue Member Functions

===== Additional member functions of the `sycl::queue` class

==== New Handler Member Functions

===== Additional member functions of the `sycl::handler` class

=== Exception Safety

=== Command-Group Function Limitations

=== Host Tasks [[host-tasks]]

=== Queue Behavior In Recording Mode

==== Event Limitations

==== Queue Limitations

==== Buffer Limitations

==== Error Handling
