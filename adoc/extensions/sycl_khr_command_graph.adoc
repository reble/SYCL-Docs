= sycl_khr_command_graph

== Overview

The command graph abstraction defines an explicitly lazy execution model by
decoupling command creation from submission. These concepts are potentially
tied together in SYCL implementations that eagerly submit work to a device when
a command-group is submitted to a queue. By providing a prior construction
stage before a workload of commands begins execution on the device, submission
of multiple commands can happen in a single submission call instead of many,
reducing the overhead of multiple independent command submissions. Deferral of
command submission can also allow for the SYCL implementation to optimize
dependencies within the user defined graph, which may improve concurrency
and other performance metrics.

== Dependencies

This extension has no dependencies on other extensions.

== Contributors

== Feature Test Macro

An implementation supporting this extension must predefine the macro
[code]#SYCL_KHR_COMMAND_GRAPH# to one of the values defined in the
table below.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

== Backend Support Status

== Usage example

The example below rewrites the application from
<<subsec:example.sycl.application>> to demonstrate the usage of this extension.

[source,role=synopsis]
----
#include <iostream>
#include <sycl/sycl.hpp>
using namespace sycl;  // (optional) avoids need for "sycl::" before SYCL names

int main() {
  // Create a queue to work on.
  queue myQueue;

  // Create some 2D buffers of float for our matrices
  buffer<float, 2> a{range<2>{N, M}};
  buffer<float, 2> b{range<2>{N, M}};
  buffer<float, 2> c{range<2>{N, M}};

  a.set_write_back(false);
  b.set_write_back(false);
  c.set_write_back(false);

  {
    khr::command_graph myGraph{
        myQueue, khr::property::graph::assume_buffer_outlives_graph{}};

    myGraph.begin_recording(myQueue);

    // Launch an asynchronous kernel to initialize a
    myQueue.submit([&](handler& cgh) {
      // The kernel writes a, so get a write accessor on it
      accessor A{a, cgh, write_only};

      // Enqueue a parallel kernel iterating on a N*M 2D iteration space
      cgh.parallel_for(range<2>{N, M}, [=](id<2> index) {
        A[index] = index[0] * 2 + index[1];
      });
    });

    // Launch an asynchronous kernel to initialize b
    myQueue.submit([&](handler& cgh) {
      // The kernel writes b, so get a write accessor on it
      accessor B{b, cgh, write_only};

      // From the access pattern above, the SYCL runtime detects that this
      // command_group is independent from the first one and can be
      // scheduled independently

      // Enqueue a parallel kernel iterating on a N*M 2D iteration space
      cgh.parallel_for(range<2>{N, M}, [=](id<2> index) {
        B[index] = index[0] * 2014 + index[1] * 42;
      });
    });

    // Launch an asynchronous kernel to compute matrix addition c = a + b
    myQueue.submit([&](handler& cgh) {
      // In the kernel a and b are read, but c is written
      accessor A{a, cgh, read_only};
      accessor B{b, cgh, read_only};
      accessor C{c, cgh, write_only};

      // From these accessors, the SYCL runtime will ensure that when
      // this kernel is run, the kernels computing a and b have completed

      // Enqueue a parallel kernel iterating on a N*M 2D iteration space
      cgh.parallel_for(range<2>{N, M},
                       [=](id<2> index) { C[index] = A[index] + B[index]; });
    });

    myGraph.end_recording();

    khr::command_graph<khr::graph_state::executable> myExecGraph =
        myGraph.finalize();

    myQueue.khr_graph(myExecGraph);
  }

  // Ask for an accessor to read c from application scope.  The SYCL runtime
  // waits for c to be ready before returning from the constructor
  host_accessor C{c, read_only};
  std::cout << std::endl << "Result:" << std::endl;
  for (size_t i = 0; i < N; i++) {
    for (size_t j = 0; j < M; j++) {
      // Compare the result to the analytic value
      if (C[i][j] != i * (2 + 2014) + j * (1 + 42)) {
        std::cout << "Wrong value " << C[i][j] << " on element " << i << " "
                  << j << std::endl;
        exit(-1);
      }
    }
  }

  std::cout << "Good computation!" << std::endl;
  return 0;
}

----

This extension adds new classes `command_graph` and `node` which follows the
common reference semantics (see <<sec:reference-semantics>>) of other SYCL runtime classes.

=== SYCL Graph Terminology [[terminology]]

==== Explicit Graph Building API

==== Queue Recording API

==== Sub-Graph

=== Node

[source, c++]
----
namespace sycl::khr {
enum class node_type {
  empty,
  subgraph,
  kernel,
  memcpy,
  memset,
  memfill,
  prefetch,
  memadvise,
  host_task,
};

class node {
public:
  node() = delete;

  node_type get_type() const;

  std::vector<node> get_predecessors() const;

  std::vector<node> get_successors() const;

  static node get_node_from_event(event nodeEvent);
};

}  // sycl::khr
----

:crs: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:reference-semantics

==== Node Member Functions

==== Depends-On Property

[source,c++]
----
namespace sycl::khr::property::node {
class depends_on {
  public:
    template<typename... NodeTN>
    depends_on(NodeTN... nodes);
};
}
----

==== Depends-On-All-Leaves Property
[source,c++]
----
namespace sycl::khr::property::node {
class depends_on_all_leaves {
  public:
    depends_on_all_leaves() = default;
};
}
----

=== Graph

[source, c++]
----
namespace sycl::khr {
// State of a graph
enum class graph_state {
  modifiable,
  executable
};

// New object representing graph
template<graph_state State = graph_state::modifiable>
class command_graph {};

template<>
class command_graph<graph_state::modifiable> {
public:
  command_graph(const context& syclContext, const device& syclDevice,
                const property_list& propList = {});

  command_graph(const queue& syclQueue,
                const property_list& propList = {});

  command_graph<graph_state::executable>
  finalize(const property_list& propList = {}) const;

  void begin_recording(queue& recordingQueue, const property_list& propList = {});
  void begin_recording(const std::vector<queue>& recordingQueues, const property_list& propList = {});

  void end_recording();
  void end_recording(queue& recordingQueue);
  void end_recording(const std::vector<queue>& recordingQueues);

  node add(const property_list& propList = {});

  template<typename T>
  node add(T cgf, const property_list& propList = {});

  void make_edge(node& src, node& dest);

  void print_graph(std::string path, bool verbose = false) const;

  std::vector<node> get_nodes() const;
  std::vector<node> get_root_nodes() const;
};

template<>
class command_graph<graph_state::executable> {
public:
    command_graph() = delete;
};

}  // namespace sycl::khr
----

==== Graph State

==== Graph Properties [[graph-properties]]

===== No-Cycle-Check Property

[source,c++]
----
namespace sycl::khr::property::graph {
class no_cycle_check {
  public:
    no_cycle_check() = default;
};
}
----

===== Assume-Buffer-Outlives-Graph Property [[assume-buffer-outlives-graph-property]]

[source,c++]
----
namespace sycl::khr::property::graph {
class assume_buffer_outlives_graph {
  public:
    assume_buffer_outlives_graph() = default;
};
}
----

==== Enable-Profiling Property [[enable-profiling]]

[source,c++]
----
namespace sycl::khr::graph {
class enable_profiling {
  public:
    enable_profiling() = default;
};
}
----

==== Graph Member Functions

===== Constructor of the `command_graph` class

===== Member functions of the `command_graph` class

===== Member functions of the `command_graph` class for queue recording

=== Queue Class Modifications

[source, c++]
----
namespace sycl {
namespace khr {
enum class queue_state {
  executing,
  recording
};

} // namespace khr

// New methods added to the sycl::queue class
using namespace khr;
class queue {
public:

  khr::queue_state
  khr_get_state() const;

  khr::command_graph<graph_state::modifiable>
  khr_get_graph() const;

  /* -- graph convenience shortcuts -- */

  event khr_graph(command_graph<graph_state::executable>& graph);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   event depEvent);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   const std::vector<event>& depEvents);
};
} // namespace sycl
----

==== Queue State

==== Transitive Queue Recording

===== Example

==== Queue Properties
      
==== New Queue Member Functions

===== Additional member functions of the `sycl::queue` class

==== New Handler Member Functions

===== Additional member functions of the `sycl::handler` class

=== Thread Safety

=== Exception Safety

=== Command-Group Function Limitations

=== Host Tasks [[host-tasks]]

=== Queue Behavior In Recording Mode

==== Event Limitations

==== Queue Limitations

==== Buffer Limitations

==== Error Handling
