= sycl_khr_graph

== Overview

The graph abstraction defines an explicitly lazy execution model by decoupling
command creation from submission. These concepts are potentially tied
together in SYCL implementations that eagerly submit work to a device when a
command-group is submitted to a queue. By providing a prior construction stage
before a workload of commands begins execution on the device, submission of
multiple commands can happen in a single submission call instead of many,
reducing the overhead of multiple independent command submissions. Deferral of
command submission can also allow for the SYCL implementation to optimize
dependencies within the user defined graph, which may improve concurrency
and other performance metrics.

== Dependencies

This extension has no dependencies on other extensions.

== Contributors

== Feature Test Macro

An implementation supporting this extension must predefine the macro
[code]#SYCL_KHR_GRAPH# to one of the values defined in the table below.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

== Backend Support Status

== Usage example


This extension adds new classes `command_graph` and `node` which follows the
common reference semantics (see <<sec:reference-semantics>>) of other SYCL runtime classes.

=== SYCL Graph Terminology [[terminology]]

==== Explicit Graph Building API

==== Queue Recording API

==== Sub-Graph

=== Node

[source, c++]
----
namespace sycl::khr {
enum class node_type {
  empty,
  subgraph,
  kernel,
  memcpy,
  memset,
  memfill,
  prefetch,
  memadvise,
  host_task,
};

class node {
public:
  node() = delete;

  node_type get_type() const;

  std::vector<node> get_predecessors() const;

  std::vector<node> get_successors() const;

  static node get_node_from_event(event nodeEvent);
};

}  // sycl::khr
----

:crs: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:reference-semantics

==== Node Member Functions

==== Depends-On Property

[source,c++]
----
namespace sycl::khr::property::node {
class depends_on {
  public:
    template<typename... NodeTN>
    depends_on(NodeTN... nodes);
};
}
----

==== Depends-On-All-Leaves Property
[source,c++]
----
namespace sycl::khr::property::node {
class depends_on_all_leaves {
  public:
    depends_on_all_leaves() = default;
};
}
----

=== Graph

[source, c++]
----
namespace sycl::khr {
// State of a graph
enum class graph_state {
  modifiable,
  executable
};

// New object representing graph
template<graph_state State = graph_state::modifiable>
class command_graph {};

template<>
class command_graph<graph_state::modifiable> {
public:
  command_graph(const context& syclContext, const device& syclDevice,
                const property_list& propList = {});

  command_graph(const queue& syclQueue,
                const property_list& propList = {});

  command_graph<graph_state::executable>
  finalize(const property_list& propList = {}) const;

  void begin_recording(queue& recordingQueue, const property_list& propList = {});
  void begin_recording(const std::vector<queue>& recordingQueues, const property_list& propList = {});

  void end_recording();
  void end_recording(queue& recordingQueue);
  void end_recording(const std::vector<queue>& recordingQueues);

  node add(const property_list& propList = {});

  template<typename T>
  node add(T cgf, const property_list& propList = {});

  void make_edge(node& src, node& dest);

  void print_graph(std::string path, bool verbose = false) const;

  std::vector<node> get_nodes() const;
  std::vector<node> get_root_nodes() const;
};

template<>
class command_graph<graph_state::executable> {
public:
    command_graph() = delete;
};

}  // namespace sycl::khr
----

==== Graph State

==== Graph Properties [[graph-properties]]

===== No-Cycle-Check Property

[source,c++]
----
namespace sycl::khr::property::graph {
class no_cycle_check {
  public:
    no_cycle_check() = default;
};
}
----

===== Assume-Buffer-Outlives-Graph Property [[assume-buffer-outlives-graph-property]]

[source,c++]
----
namespace sycl::khr::property::graph {
class assume_buffer_outlives_graph {
  public:
    assume_buffer_outlives_graph() = default;
};
}
----

==== Enable-Profiling Property [[enable-profiling]]

[source,c++]
----
namespace sycl::khr::graph {
class enable_profiling {
  public:
    enable_profiling() = default;
};
}
----

==== Graph Member Functions

===== Constructor of the `command_graph` class

===== Member functions of the `command_graph` class

===== Member functions of the `command_graph` class for queue recording

=== Queue Class Modifications

[source, c++]
----
namespace sycl {
namespace khr {
enum class queue_state {
  executing,
  recording
};

} // namespace khr

// New methods added to the sycl::queue class
using namespace khr;
class queue {
public:

  khr::queue_state
  khr_get_state() const;

  khr::command_graph<graph_state::modifiable>
  khr_get_graph() const;

  /* -- graph convenience shortcuts -- */

  event khr_graph(command_graph<graph_state::executable>& graph);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   event depEvent);
  event khr_graph(command_graph<graph_state::executable>& graph,
                   const std::vector<event>& depEvents);
};
} // namespace sycl
----

==== Queue State

==== Transitive Queue Recording

===== Example

==== Queue Properties
      
==== New Queue Member Functions

===== Additional member functions of the `sycl::queue` class

==== New Handler Member Functions

===== Additional member functions of the `sycl::handler` class

=== Thread Safety

=== Exception Safety

=== Command-Group Function Limitations

=== Host Tasks [[host-tasks]]

=== Queue Behavior In Recording Mode

==== Event Limitations

==== Queue Limitations

==== Buffer Limitations

==== Error Handling
